#include <iostream>
#include <tuple>
#include "sparse/matrix.hpp"

/**
 * @file main.cpp
 * @brief Демонстрация бесконечной разреженной матрицы.
 *
 * Требования:
 *  1) Matrix<int, 0>, главная диагональ (0..9) = 0..9
 *  2) Побочная диагональ (0..9) = 9..0
 *  3) Печать фрагмента [1,1]..[8,8] (строки по новой строке, между столбцами пробел)
 *  4) Печать числа занятых ячеек (ожидается 18)
 *  5) Печать всех занятых ячеек (x y v)
 *  6) Опц.: ((matrix[100][100] = 314) = 0) = 217
 */

int main() {
    using sparse::Matrix;

    // 0 пример из задания для самоконтроля
    {
        Matrix<int, -1> m;
        auto a = m[0][0];
        (void)a;
        m[100][100] = 314;
        for (auto t : m) {
            int x, y, v;
            std::tie(x, y, v) = t;
            std::cout << x << y << v << "\n";
        }
    }

    // 1) матрица int с пустым значением 0
    Matrix<int, 0> matrix;

    // 2) главная диагональ: [i,i] = i  (i=0..9)
    for (int i = 0; i < 10; ++i) {
        matrix[i][i] = i; // ячейка (0,0) получит 0 -> удалится, что важно для size
    }

    // 3) побочная диагональ: [i 9-i] = 9-i  (i=0 9)
    for (int i = 0; i < 10; ++i) {
        matrix[i][9 - i] = 9 - i; // ячейка (9,0) получит 0 -> удалится
    }

    // 4) выведем фрагмент [1,1]..[8,8]
    for (int y = 1; y <= 8; ++y) {
        for (int x = 1; x <= 8; ++x) {
            if (x > 1) std::cout << ' ';
            std::cout << static_cast<int>(matrix[x][y]);
        }
        std::cout << '\n';
    }

    // 5) количество занятых ячеек (ожидается 18)
    std::cout << matrix.size() << '\n';

    // 6) вывести все занятые ячейки
    for (auto cell : matrix) {
        int x, y, v;
        std::tie(x, y, v) = cell;
        std::cout << x << ' ' << y << ' ' << v << '\n';
    }

    // 7) опционально каноническая форма оператора =
    ((matrix[100][100] = 314) = 0) = 217;
    // можно проверить:
    // std::cout << static_cast<int>(matrix[100][100]) << '\n'; // 217

    return 0;
}
